import { Client, LocalAuth, MessageMedia } from "whatsapp-web.js";\nimport qrcode from "qrcode";\nimport fs from "fs";\nimport path from "path";\nimport { getDb } from "../db";\nimport { whatsappConfigs, whatsappMessages } from "../../drizzle/schema";\nimport { eq } from "drizzle-orm";\n\ninterface WhatsAppSession {\n  phoneNumber: string;\n  isConnected: boolean;\n  qrCode?: string;\n  lastConnected?: Date;\n  sessionPath: string;\n}\n\nclass WhatsAppAdvancedService {\n  private clients: Map<string, Client> = new Map();\n  private sessions: Map<string, WhatsAppSession> = new Map();\n  private sessionStoragePath = path.join(process.cwd(), \".whatsapp-sessions\");\n\n  constructor() {\n    this.ensureSessionStoragePath();\n    this.loadExistingSessions();\n  }\n\n  /**\n   * Garante que o diretório de armazenamento de sessões existe\n   */\n  private ensureSessionStoragePath() {\n    if (!fs.existsSync(this.sessionStoragePath)) {\n      fs.mkdirSync(this.sessionStoragePath, { recursive: true });\n    }\n  }\n\n  /**\n   * Carrega sessões existentes do banco de dados\n   */\n  private async loadExistingSessions() {\n    try {\n      const db = await getDb();\n      if (!db) return;\n\n      const configs = await db.select().from(whatsappConfigs);\n      for (const config of configs) {\n        if (config.isActive && config.sessionData) {\n          // Tentar reconectar\n          await this.connectSession(config.phoneNumber);\n        }\n      }\n    } catch (error) {\n      console.error(\"Erro ao carregar sessões WhatsApp:\", error);\n    }\n  }\n\n  /**\n   * Inicia uma nova sessão WhatsApp e gera QR code\n   */\n  async connectSession(phoneNumber: string): Promise<{\n    qrCode: string;\n    status: string;\n  }> {\n    try {\n      // Verificar se já existe uma sessão ativa\n      if (this.clients.has(phoneNumber)) {\n        const client = this.clients.get(phoneNumber)!;\n        const state = await client.getState();\n        if (state === \"CONNECTED\") {\n          return {\n            qrCode: \"\",\n            status: \"already_connected\",\n          };\n        }\n      }\n\n      // Criar novo cliente\n      const sessionPath = path.join(this.sessionStoragePath, phoneNumber);\n      const client = new Client({\n        authStrategy: new LocalAuth({\n          clientId: phoneNumber,\n          dataPath: sessionPath,\n        }),\n        puppeteer: {\n          headless: true,\n          args: [\"--no-sandbox\", \"--disable-setuid-sandbox\"],\n        },\n      });\n\n      let qrCodeData = \"\";\n\n      // Event: QR code gerado\n      client.on(\"qr\", async (qr) => {\n        console.log(`QR Code gerado para ${phoneNumber}`);\n        qrCodeData = await qrcode.toDataURL(qr);\n        \n        // Salvar QR code temporariamente\n        this.sessions.set(phoneNumber, {\n          phoneNumber,\n          isConnected: false,\n          qrCode: qrCodeData,\n          sessionPath,\n        });\n      });\n\n      // Event: Cliente pronto\n      client.on(\"ready\", async () => {\n        console.log(`WhatsApp conectado para ${phoneNumber}`);\n        \n        const db = await getDb();\n        if (db) {\n          // Salvar configuração no banco\n          const sessionData = fs.readFileSync(\n            path.join(sessionPath, \"Default\", \"session\"),\n            \"utf-8\"\n          );\n\n          await db\n            .insert(whatsappConfigs)\n            .values({\n              phoneNumber,\n              isActive: true,\n              sessionData,\n              lastConnected: new Date(),\n            })\n            .onDuplicateKeyUpdate({\n              set: {\n                isActive: true,\n                sessionData,\n                lastConnected: new Date(),\n              },\n            });\n        }\n\n        // Atualizar sessão\n        this.sessions.set(phoneNumber, {\n          phoneNumber,\n          isConnected: true,\n          lastConnected: new Date(),\n          sessionPath,\n        });\n      });\n\n      // Event: Desconectado\n      client.on(\"disconnected\", async () => {\n        console.log(`WhatsApp desconectado para ${phoneNumber}`);\n        this.clients.delete(phoneNumber);\n        \n        const db = await getDb();\n        if (db) {\n          await db\n            .update(whatsappConfigs)\n            .set({ isActive: false })\n            .where(eq(whatsappConfigs.phoneNumber, phoneNumber));\n        }\n      });\n\n      // Event: Erro\n      client.on(\"error\", (error) => {\n        console.error(`Erro WhatsApp para ${phoneNumber}:`, error);\n      });\n\n      // Inicializar cliente\n      await client.initialize();\n      this.clients.set(phoneNumber, client);\n\n      return {\n        qrCode: qrCodeData,\n        status: \"waiting_for_scan\",\n      };\n    } catch (error) {\n      console.error(`Erro ao conectar WhatsApp para ${phoneNumber}:`, error);\n      throw new Error(`Falha ao conectar WhatsApp: ${error}`);\n    }\n  }\n\n  /**\n   * Desconecta uma sessão WhatsApp\n   */\n  async disconnectSession(phoneNumber: string): Promise<void> {\n    try {\n      const client = this.clients.get(phoneNumber);\n      if (client) {\n        await client.destroy();\n        this.clients.delete(phoneNumber);\n      }\n\n      const db = await getDb();\n      if (db) {\n        await db\n          .update(whatsappConfigs)\n          .set({ isActive: false })\n          .where(eq(whatsappConfigs.phoneNumber, phoneNumber));\n      }\n\n      this.sessions.delete(phoneNumber);\n    } catch (error) {\n      console.error(`Erro ao desconectar WhatsApp para ${phoneNumber}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Envia uma mensagem de texto via WhatsApp\n   */\n  async sendTextMessage(\n    phoneNumber: string,\n    recipientPhone: string,\n    message: string\n  ): Promise<{ success: boolean; messageId?: string; error?: string }> {\n    try {\n      const client = this.clients.get(phoneNumber);\n      if (!client) {\n        return {\n          success: false,\n          error: \"Cliente WhatsApp não conectado\",\n        };\n      }\n\n      const state = await client.getState();\n      if (state !== \"CONNECTED\") {\n        return {\n          success: false,\n          error: \"Cliente WhatsApp não está conectado\",\n        };\n      }\n\n      // Formatar número (adicionar código de país se necessário)\n      const formattedPhone = this.formatPhoneNumber(recipientPhone);\n      const chatId = `${formattedPhone}@c.us`;\n\n      // Enviar mensagem\n      const response = await client.sendMessage(chatId, message);\n\n      // Salvar no banco de dados\n      const db = await getDb();\n      if (db) {\n        await db.insert(whatsappMessages).values({\n          senderPhone: phoneNumber,\n          recipientPhone: formattedPhone,\n          message,\n          status: \"sent\",\n          messageId: response.id._serialized,\n          sentAt: new Date(),\n        });\n      }\n\n      return {\n        success: true,\n        messageId: response.id._serialized,\n      };\n    } catch (error) {\n      console.error(`Erro ao enviar mensagem WhatsApp:`, error);\n      return {\n        success: false,\n        error: `Erro ao enviar mensagem: ${error}`,\n      };\n    }\n  }\n\n  /**\n   * Envia uma mensagem com mídia (imagem, áudio, vídeo)\n   */\n  async sendMediaMessage(\n    phoneNumber: string,\n    recipientPhone: string,\n    mediaUrl: string,\n    caption?: string\n  ): Promise<{ success: boolean; messageId?: string; error?: string }> {\n    try {\n      const client = this.clients.get(phoneNumber);\n      if (!client) {\n        return {\n          success: false,\n          error: \"Cliente WhatsApp não conectado\",\n        };\n      }\n\n      const state = await client.getState();\n      if (state !== \"CONNECTED\") {\n        return {\n          success: false,\n          error: \"Cliente WhatsApp não está conectado\",\n        };\n      }\n\n      // Baixar mídia\n      const media = await MessageMedia.fromUrl(mediaUrl);\n\n      // Formatar número\n      const formattedPhone = this.formatPhoneNumber(recipientPhone);\n      const chatId = `${formattedPhone}@c.us`;\n\n      // Enviar mídia\n      const response = await client.sendMessage(chatId, media, {\n        caption: caption || \"\",\n      });\n\n      // Salvar no banco de dados\n      const db = await getDb();\n      if (db) {\n        await db.insert(whatsappMessages).values({\n          senderPhone: phoneNumber,\n          recipientPhone: formattedPhone,\n          message: caption || \"[Mídia]\",\n          status: \"sent\",\n          messageId: response.id._serialized,\n          mediaUrl,\n          sentAt: new Date(),\n        });\n      }\n\n      return {\n        success: true,\n        messageId: response.id._serialized,\n      };\n    } catch (error) {\n      console.error(`Erro ao enviar mídia WhatsApp:`, error);\n      return {\n        success: false,\n        error: `Erro ao enviar mídia: ${error}`,\n      };\n    }\n  }\n\n  /**\n   * Envia mensagem em massa para múltiplos contatos\n   */\n  async sendBulkMessages(\n    phoneNumber: string,\n    recipients: string[],\n    message: string\n  ): Promise<{\n    success: number;\n    failed: number;\n    results: Array<{ phone: string; success: boolean; error?: string }>;\n  }> {\n    const results = [];\n    let successCount = 0;\n    let failedCount = 0;\n\n    for (const recipient of recipients) {\n      const result = await this.sendTextMessage(phoneNumber, recipient, message);\n      if (result.success) {\n        successCount++;\n        results.push({ phone: recipient, success: true });\n      } else {\n        failedCount++;\n        results.push({\n          phone: recipient,\n          success: false,\n          error: result.error,\n        });\n      }\n\n      // Aguardar um pouco entre mensagens para evitar rate limit\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n\n    return {\n      success: successCount,\n      failed: failedCount,\n      results,\n    };\n  }\n\n  /**\n   * Obtém o status de uma sessão WhatsApp\n   */\n  async getSessionStatus(phoneNumber: string): Promise<WhatsAppSession | null> {\n    const session = this.sessions.get(phoneNumber);\n    if (!session) return null;\n\n    const client = this.clients.get(phoneNumber);\n    if (client) {\n      const state = await client.getState();\n      session.isConnected = state === \"CONNECTED\";\n    }\n\n    return session;\n  }\n\n  /**\n   * Lista todas as sessões ativas\n   */\n  async listActiveSessions(): Promise<WhatsAppSession[]> {\n    const sessions: WhatsAppSession[] = [];\n\n    for (const [phoneNumber] of this.clients) {\n      const session = await this.getSessionStatus(phoneNumber);\n      if (session) {\n        sessions.push(session);\n      }\n    }\n\n    return sessions;\n  }\n\n  /**\n   * Formata número de telefone para o padrão WhatsApp\n   */\n  private formatPhoneNumber(phone: string): string {\n    // Remover caracteres especiais\n    let cleaned = phone.replace(/\\D/g, \"\");\n\n    // Se não tiver código de país, adicionar 55 (Brasil)\n    if (cleaned.length === 11) {\n      cleaned = `55${cleaned}`;\n    } else if (cleaned.length === 10) {\n      cleaned = `55${cleaned}`;\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * Obtém histórico de mensagens\n   */\n  async getMessageHistory(\n    phoneNumber: string,\n    limit: number = 50\n  ): Promise<any[]> {\n    try {\n      const db = await getDb();\n      if (!db) return [];\n\n      const messages = await db\n        .select()\n        .from(whatsappMessages)\n        .where(eq(whatsappMessages.senderPhone, phoneNumber))\n        .orderBy((t) => t.sentAt)\n        .limit(limit);\n\n      return messages;\n    } catch (error) {\n      console.error(\"Erro ao obter histórico de mensagens:\", error);\n      return [];\n    }\n  }\n}\n\nexport default new WhatsAppAdvancedService();\n
